/**
 * Multilingual AI Chatbot for Customer Support
 * Supports English, Nepali, Chinese, Korean, Japanese
 */

export interface ChatMessage {
  id: string;
  sessionId: string;
  userId?: string;
  content: string;
  language: 'en' | 'ne' | 'zh' | 'ko' | 'ja';
  type: 'user' | 'bot';
  timestamp: Date;
  intent?: string;
  confidence?: number;
  attachments?: MessageAttachment[];
}

export interface MessageAttachment {
  id: string;
  type: 'image' | 'document' | 'audio';
  url: string;
  name: string;
  size: number;
}

export interface ChatSession {
  id: string;
  userId?: string;
  language: string;
  status: 'active' | 'waiting' | 'resolved' | 'escalated';
  startTime: Date;
  endTime?: Date;
  messages: ChatMessage[];
  context: SessionContext;
  satisfaction?: number; // 1-5 rating
}

export interface SessionContext {
  userType: 'customer' | 'client' | 'enterprise' | 'guest';
  currentPage?: string;
  previousIssues: string[];
  accountStatus?: string;
  verificationLevel?: string;
  preferredLanguage: string;
}

export interface BotResponse {
  content: string;
  suggestions?: string[];
  quickActions?: QuickAction[];
  escalateToHuman?: boolean;
  attachments?: MessageAttachment[];
}

export interface QuickAction {
  id: string;
  label: string;
  action: 'navigate' | 'start_verification' | 'download' | 'contact_support' | 'faq';
  parameters?: Record<string, any>;
}

export interface IntentClassification {
  intent: string;
  confidence: number;
  entities: Entity[];
  language: string;
}

export interface Entity {
  type: 'verification_type' | 'document_type' | 'problem_category' | 'account_info';
  value: string;
  confidence: number;
}

class MultilingualChatbot {
  private sessions: Map<string, ChatSession> = new Map();
  private knowledgeBase: Map<string, Map<string, string>> = new Map(); // language -> intent -> response
  private intentClassifier: IntentClassifier;
  private languageDetector: LanguageDetector;

  constructor() {
    this.intentClassifier = new IntentClassifier();
    this.languageDetector = new LanguageDetector();
    this.initializeKnowledgeBase();
  }

  private initializeKnowledgeBase() {
    // English knowledge base
    const englishKB = new Map([
      ['greeting', 'Hello! I\'m Veridity AI Assistant. How can I help you with your identity verification today?'],
      ['proof_generation', 'I can help you generate identity proofs. What type of verification do you need? We support age, citizenship, education, and employment verification.'],
      ['verification_help', 'To verify a proof, you\'ll need the proof ID and verification key. Would you like me to guide you through the process?'],
      ['account_issues', 'I\'m here to help with account issues. Can you describe what problem you\'re experiencing?'],
      ['technical_support', 'For technical issues, I can provide immediate assistance. What specific problem are you facing?'],
      ['pricing_info', 'Our pricing starts at $9.99/month for basic verification. Would you like to see our full pricing plans?'],
      ['security_concerns', 'Security is our top priority. All data is encrypted and we use zero-knowledge proofs. What security question do you have?'],
      ['mobile_app', 'Yes, we have mobile apps for iOS and Android with full verification capabilities. Would you like download links?'],
      ['api_integration', 'Our API supports easy integration. I can provide documentation and code examples. What platform are you using?'],
      ['goodbye', 'Thank you for using Veridity! Feel free to reach out anytime if you need assistance.']
    ]);

    // Nepali knowledge base
    const nepaliKB = new Map([
      ['greeting', 'рдирдорд╕реНрддреЗ! рдо Veridity AI рд╕рд╣рд╛рдпрдХ рд╣реБрдБред рдЖрдЬрдХреЛ рдкрд╣рд┐рдЪрд╛рди рдкреНрд░рдорд╛рдгреАрдХрд░рдгрдорд╛ рдо рддрдкрд╛рдИрдВрд▓рд╛рдИ рдХрд╕рд░реА рдорджреНрджрдд рдЧрд░реНрди рд╕рдХреНрдЫреБ?'],
      ['proof_generation', 'рдо рддрдкрд╛рдИрдВрд▓рд╛рдИ рдкрд╣рд┐рдЪрд╛рди рдкреНрд░рдорд╛рдг рдЙрддреНрдкрдиреНрди рдЧрд░реНрди рдорджреНрджрдд рдЧрд░реНрди рд╕рдХреНрдЫреБред рддрдкрд╛рдИрдВрд▓рд╛рдИ рдХреБрди рдкреНрд░рдХрд╛рд░рдХреЛ рдкреНрд░рдорд╛рдгреАрдХрд░рдг рдЪрд╛рд╣рд┐рдиреНрдЫ?'],
      ['verification_help', 'рдкреНрд░рдорд╛рдг рдкреНрд░рдорд╛рдгреАрдХрд░рдг рдЧрд░реНрди рддрдкрд╛рдИрдВрд▓рд╛рдИ рдкреНрд░рдорд╛рдг ID рд░ рдкреНрд░рдорд╛рдгреАрдХрд░рдг рдХреБрдЮреНрдЬреА рдЪрд╛рд╣рд┐рдиреНрдЫред рдХреЗ рдо рддрдкрд╛рдИрдВрд▓рд╛рдИ рдкреНрд░рдХреНрд░рд┐рдпрд╛рдорд╛ рдорд╛рд░реНрдЧрджрд░реНрд╢рди рдЧрд░реВрдВ?'],
      ['account_issues', 'рдо рдЦрд╛рддрд╛ рд╕рдорд╕реНрдпрд╛рд╣рд░реВрдорд╛ рдорджреНрджрдд рдЧрд░реНрди рдпрд╣рд╛рдБ рдЫреБред рддрдкрд╛рдИрдВрд▓реЗ рдЕрдиреБрднрд╡ рдЧрд░рд┐рд░рд╣рдиреБрднрдПрдХреЛ рд╕рдорд╕реНрдпрд╛ рд╡рд░реНрдгрди рдЧрд░реНрди рд╕рдХреНрдиреБрд╣реБрдиреНрдЫ?'],
      ['technical_support', 'рдкреНрд░рд╛рд╡рд┐рдзрд┐рдХ рд╕рдорд╕реНрдпрд╛рд╣рд░реВрдХреЛ рд▓рд╛рдЧрд┐, рдо рддрддреНрдХрд╛рд▓ рд╕рд╣рд╛рдпрддрд╛ рдкреНрд░рджрд╛рди рдЧрд░реНрди рд╕рдХреНрдЫреБред рддрдкрд╛рдИрдВ рдХреБрди рд╕рдорд╕реНрдпрд╛рдХреЛ рд╕рд╛рдордирд╛ рдЧрд░реНрджреИ рд╣реБрдиреБрд╣реБрдиреНрдЫ?'],
      ['pricing_info', 'рд╣рд╛рдореНрд░реЛ рдореВрд▓реНрдп рдЖрдзрд╛рд░рднреВрдд рдкреНрд░рдорд╛рдгреАрдХрд░рдгрдХреЛ рд▓рд╛рдЧрд┐ $реп.репреп/рдорд╣рд┐рдирд╛рдмрд╛рдЯ рд╕реБрд░реБ рд╣реБрдиреНрдЫред рдХреЗ рддрдкрд╛рдИрдВ рд╣рд╛рдореНрд░реЛ рдкреВрд░реНрдг рдореВрд▓реНрдп рдпреЛрдЬрдирд╛рд╣рд░реВ рд╣реЗрд░реНрди рдЪрд╛рд╣рдиреБрд╣реБрдиреНрдЫ?'],
      ['goodbye', 'Veridity рдкреНрд░рдпреЛрдЧ рдЧрд░реНрдиреБрднрдПрдХреЛрдорд╛ рдзрдиреНрдпрд╡рд╛рдж! рдпрджрд┐ рддрдкрд╛рдИрдВрд▓рд╛рдИ рд╕рд╣рд╛рдпрддрд╛ рдЪрд╛рд╣рд┐рдиреНрдЫ рднрдиреЗ рдЬрд╣рд┐рд▓реЗ рдкрдирд┐ рд╕рдореНрдкрд░реНрдХ рдЧрд░реНрдиреБрд╣реЛрд╕реНред']
    ]);

    // Chinese knowledge base
    const chineseKB = new Map([
      ['greeting', 'цВихе╜я╝БцИСцШпVeridity AIхКйцЙЛуАВф╗КхдйцИСхПпф╗ехжВф╜Хх╕охКйцВиш┐ЫшбМш║лф╗╜щкМшпБя╝Я'],
      ['proof_generation', 'цИСхПпф╗ех╕охКйцВичФЯцИРш║лф╗╜шпБцШОуАВцВищЬАшжБф╗Аф╣Ич▒╗хЮЛчЪДщкМшпБя╝ЯцИСф╗мцФпцМБх╣┤щ╛ДуАБхЕмц░Сш║лф╗╜уАБцХЩшВ▓хТМх░▒ф╕ЪщкМшпБуАВ'],
      ['verification_help', 'шжБщкМшпБшпБцШОя╝МцВищЬАшжБшпБцШОIDхТМщкМшпБхпЖщТеуАВцВих╕МцЬЫцИСцМЗхп╝цВихоМцИРш┐Щф╕кш┐ЗчиЛхРЧя╝Я'],
      ['account_issues', 'цИСхЬиш┐ЩщЗМх╕охКйшзгхЖ│ш┤жцИ╖щЧощвШуАВцВишГ╜цППш┐░ф╕Аф╕ЛщБЗхИ░чЪДщЧощвШхРЧя╝Я'],
      ['technical_support', 'хп╣ф║ОцКАцЬпщЧощвШя╝МцИСхПпф╗ецПРф╛ЫхН│цЧ╢х╕охКйуАВцВищЭвф╕┤ф╗Аф╣ИхЕ╖ф╜УщЧощвШя╝Я'],
      ['pricing_info', 'цИСф╗мчЪДхоЪф╗╖ф╗ОхЯ║чбАщкМшпБчЪДцпПцЬИ$9.99х╝АхзЛуАВцВицГ│цЯечЬЛцИСф╗мчЪДхоМцХ┤хоЪф╗╖шобхИТхРЧя╝Я'],
      ['goodbye', 'цДЯш░вцВиф╜┐чФиVeridityя╝БхжВцЮЬцВищЬАшжБх╕охКйя╝Мшп╖щЪПцЧ╢шБФч│╗цИСф╗муАВ']
    ]);

    // Korean knowledge base
    const koreanKB = new Map([
      ['greeting', 'ьХИыЕХэХШьД╕ьЪФ! ьаАыКФ Veridity AI ьЦ┤ьЛЬьКдэД┤эК╕ьЮЕыЛИыЛд. ьШдыКШ ьЛаьЫР эЩХьЭ╕ьЧР ьЦ┤ыЦ╗ъ▓М ыПДьЫАьЭД ыУЬыж┤ъ╣МьЪФ?'],
      ['proof_generation', 'ьЛаьЫР ьжЭыкЕ ьГЭьД▒ьЭД ыПДьЩАыУЬыж┤ ьИШ ьЮИьК╡ыЛИыЛд. ьЦ┤ыЦд ьЬаэШХьЭШ ъ▓АьжЭьЭ┤ эХДьЪФэХШьЛаъ░АьЪФ? ьЧ░ыа╣, ьЛЬып╝ъ╢М, ъ╡РьЬб, ъ│аьЪй ъ▓АьжЭьЭД ьзАьЫРэХйыЛИыЛд.'],
      ['verification_help', 'ьжЭыкЕьЭД ъ▓АьжЭэХШыадый┤ ьжЭыкЕ IDьЩА ъ▓АьжЭ эВдъ░А эХДьЪФэХйыЛИыЛд. ъ│╝ьаХьЭД ьХИыВ┤эХ┤ ыУЬыж┤ъ╣МьЪФ?'],
      ['account_issues', 'ъ│ДьаХ ым╕ьаЬые╝ ыПДьЩАыУЬыжмъ╕░ ьЬДэХ┤ ьЧмъ╕░ ьЮИьК╡ыЛИыЛд. ьЦ┤ыЦд ым╕ьаЬые╝ ъ▓къ│а ъ│ДьЛаьзА ьДдыкЕэХ┤ ьг╝ьЛд ьИШ ьЮИыВШьЪФ?'],
      ['technical_support', 'ъ╕░ьИаьаБ ым╕ьаЬьЧР ыМАэХ┤ ьжЙьЛЬ ьзАьЫРьЭД ьаЬъ│╡эХа ьИШ ьЮИьК╡ыЛИыЛд. ьЦ┤ыЦд ъ╡мь▓┤ьаБьЭ╕ ым╕ьаЬые╝ ъ▓къ│а ъ│ДьЛаъ░АьЪФ?'],
      ['pricing_info', 'ъ╕░ы│╕ ъ▓АьжЭьЭШ ъ▓╜ьЪ░ ьЫФ $9.99ы╢АэД░ ьЛЬьЮСэХйыЛИыЛд. ьаДь▓┤ ьЪФъ╕ИьаЬые╝ ы│┤ьЛЬъ▓аьК╡ыЛИъ╣М?'],
      ['goodbye', 'Veridityые╝ ьЭ┤ьЪйэХ┤ ьг╝ьЕФьДЬ ъ░РьВмэХйыЛИыЛд! ыПДьЫАьЭ┤ эХДьЪФэХШьЛЬый┤ ьЦ╕ьаЬыУаьзА ьЧ░ыЭ╜эХ┤ ьг╝ьД╕ьЪФ.']
    ]);

    // Japanese knowledge base
    const japaneseKB = new Map([
      ['greeting', 'уБУуВУуБлуБбуБпя╝БчзБуБпVeridity AIуВвуВ╖уВ╣уВ┐уГ│уГИуБзуБЩуАВф╗КцЧеуАБцЬмф║║чв║шкНуБлуБдуБДуБжуБйуБоуВИуБЖуБлуБКцЙЛф╝ЭуБДуБзуБНуБ╛уБЩуБЛя╝Я'],
      ['proof_generation', 'ш║лхЕГши╝цШОуБочФЯцИРуВТуБКцЙЛф╝ЭуБДуБзуБНуБ╛уБЩуАВуБйуБоуВИуБЖуБкчиощбЮуБоцдЬши╝уБМх┐ЕшжБуБзуБЩуБЛя╝Ях╣┤щ╜вуАБх╕Вц░СцийуАБцХЩшВ▓уАБщЫЗчФиуБоцдЬши╝уВТуВ╡уГЭуГ╝уГИуБЧуБжуБДуБ╛уБЩуАВ'],
      ['verification_help', 'ши╝цШОуВТцдЬши╝уБЩуВЛуБлуБпуАБши╝цШОIDуБицдЬши╝уВнуГ╝уБМх┐ЕшжБуБзуБЩуАВуГЧуГнуВ╗уВ╣уВТуВмуВдуГЙуБЧуБ╛уБЧуВЗуБЖуБЛя╝Я'],
      ['account_issues', 'уВвуВлуВжуГ│уГИуБохХПщбМуВТуБКцЙЛф╝ЭуБДуБЩуВЛуБЯуВБуБлуБУуБУуБлуБДуБ╛уБЩуАВч╡МщиУуБЧуБжуБДуВЛхХПщбМуБлуБдуБДуБжшкмцШОуБЧуБжуБДуБЯуБауБСуБ╛уБЩуБЛя╝Я'],
      ['technical_support', 'цКАшбУчЪДуБкхХПщбМуБлуБдуБДуБжуБпуАБуБЩуБРуБлуВ╡уГЭуГ╝уГИуВТцПРф╛ЫуБзуБНуБ╛уБЩуАВуБйуБоуВИуБЖуБкхЕ╖ф╜УчЪДуБкхХПщбМуБлчЫ┤щЭвуБЧуБжуБДуБ╛уБЩуБЛя╝Я'],
      ['pricing_info', 'хЯ║цЬмцдЬши╝уБоцЦЩщЗСуБпцЬИщбН$9.99уБЛуВЙхзЛуБ╛уВКуБ╛уБЩуАВхоМхЕиуБкцЦЩщЗСуГЧуГйуГ│уВТуБФшжзуБлуБкуВКуБ╛уБЩуБЛя╝Я'],
      ['goodbye', 'VeridityуВТуБФхИйчФиуБДуБЯуБауБНуБВуВКуБМуБиуБЖуБФуБЦуБДуБ╛уБЩя╝БуВ╡уГЭуГ╝уГИуБМх┐ЕшжБуБкха┤хРИуБпуАБуБДуБдуБзуВВуБКц░Чш╗╜уБлуБКхХПуБДхРИуВПуБЫуБПуБауБХуБДуАВ']
    ]);

    this.knowledgeBase.set('en', englishKB);
    this.knowledgeBase.set('ne', nepaliKB);
    this.knowledgeBase.set('zh', chineseKB);
    this.knowledgeBase.set('ko', koreanKB);
    this.knowledgeBase.set('ja', japaneseKB);

    console.log('ЁЯдЦ Initialized multilingual knowledge base with 5 languages');
  }

  // Start new chat session
  async startChatSession(userId?: string, preferredLanguage: string = 'en'): Promise<string> {
    const sessionId = `chat-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    const session: ChatSession = {
      id: sessionId,
      userId,
      language: preferredLanguage,
      status: 'active',
      startTime: new Date(),
      messages: [],
      context: {
        userType: userId ? 'customer' : 'guest',
        previousIssues: [],
        preferredLanguage
      }
    };

    this.sessions.set(sessionId, session);

    // Send welcome message
    const welcomeMessage = await this.generateBotResponse('greeting', preferredLanguage, session.context);
    await this.addMessage(sessionId, welcomeMessage.content, 'bot', preferredLanguage);

    console.log(`ЁЯТм Started chat session: ${sessionId} (${preferredLanguage})`);
    return sessionId;
  }

  // Process user message
  async processMessage(sessionId: string, content: string, attachments?: MessageAttachment[]): Promise<BotResponse> {
    const session = this.sessions.get(sessionId);
    if (!session) {
      throw new Error('Chat session not found');
    }

    // Detect language if not specified
    const detectedLanguage = await this.languageDetector.detect(content);
    const language = detectedLanguage || session.language;

    // Add user message
    await this.addMessage(sessionId, content, 'user', language, attachments);

    // Classify intent
    const classification = await this.intentClassifier.classify(content, language);

    // Generate response
    const response = await this.generateBotResponse(classification.intent, language, session.context, classification.entities);

    // Add bot response
    await this.addMessage(sessionId, response.content, 'bot', language);

    // Update session context
    this.updateSessionContext(session, classification);

    return response;
  }

  private async addMessage(
    sessionId: string,
    content: string,
    type: 'user' | 'bot',
    language: string,
    attachments?: MessageAttachment[]
  ): Promise<void> {
    const session = this.sessions.get(sessionId);
    if (!session) return;

    const message: ChatMessage = {
      id: `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      sessionId,
      userId: session.userId,
      content,
      language: language as ChatMessage['language'],
      type,
      timestamp: new Date(),
      attachments
    };

    session.messages.push(message);
  }

  private async generateBotResponse(
    intent: string,
    language: string,
    context: SessionContext,
    entities?: Entity[]
  ): Promise<BotResponse> {
    const kb = this.knowledgeBase.get(language) || this.knowledgeBase.get('en')!;
    let baseResponse = kb.get(intent) || kb.get('greeting')!;

    const suggestions: string[] = [];
    const quickActions: QuickAction[] = [];
    let escalateToHuman = false;

    // Customize response based on intent and entities
    switch (intent) {
      case 'proof_generation':
        suggestions.push('Age Verification', 'Citizenship Proof', 'Education Certificate', 'Employment Verification');
        quickActions.push({
          id: 'start-verification',
          label: 'Start Verification',
          action: 'start_verification'
        });
        break;

      case 'verification_help':
        quickActions.push({
          id: 'verify-proof',
          label: 'Verify Proof',
          action: 'navigate',
          parameters: { page: '/verify' }
        });
        break;

      case 'technical_support':
        if (context.userType === 'enterprise') {
          escalateToHuman = true;
          baseResponse += ' I\'ll connect you with our technical support team for priority assistance.';
        }
        break;

      case 'api_integration':
        quickActions.push({
          id: 'view-docs',
          label: 'API Documentation',
          action: 'navigate',
          parameters: { page: '/docs/api' }
        });
        break;

      case 'mobile_app':
        quickActions.push(
          {
            id: 'ios-download',
            label: 'Download iOS App',
            action: 'download',
            parameters: { platform: 'ios' }
          },
          {
            id: 'android-download',
            label: 'Download Android App',
            action: 'download',
            parameters: { platform: 'android' }
          }
        );
        break;
    }

    // Add context-aware suggestions
    if (context.userType === 'client') {
      suggestions.push('Integration Help', 'API Documentation', 'Webhook Setup');
    }

    return {
      content: baseResponse,
      suggestions: suggestions.length > 0 ? suggestions : undefined,
      quickActions: quickActions.length > 0 ? quickActions : undefined,
      escalateToHuman
    };
  }

  private updateSessionContext(session: ChatSession, classification: IntentClassification): void {
    session.context.preferredLanguage = classification.language;

    // Track previous issues for better context
    if (!session.context.previousIssues.includes(classification.intent)) {
      session.context.previousIssues.push(classification.intent);
    }

    // Update user type based on conversation
    const entities = classification.entities;
    const hasApiQuestions = entities.some(e => e.type === 'verification_type' && e.value.includes('api'));
    const hasEnterpriseQuestions = session.context.previousIssues.some(issue => 
      ['api_integration', 'technical_support', 'enterprise_features'].includes(issue)
    );

    if (hasApiQuestions || hasEnterpriseQuestions) {
      session.context.userType = 'client';
    }
  }

  // End chat session
  async endChatSession(sessionId: string, satisfaction?: number): Promise<boolean> {
    const session = this.sessions.get(sessionId);
    if (!session) return false;

    session.status = 'resolved';
    session.endTime = new Date();
    session.satisfaction = satisfaction;

    console.log(`ЁЯТм Ended chat session: ${sessionId} (satisfaction: ${satisfaction || 'N/A'})`);
    return true;
  }

  // Get chat history
  getChatHistory(sessionId: string): ChatMessage[] {
    const session = this.sessions.get(sessionId);
    return session?.messages || [];
  }

  // Get active sessions
  getActiveSessions(): ChatSession[] {
    return Array.from(this.sessions.values()).filter(s => s.status === 'active');
  }

  // Analytics
  async getChatAnalytics(): Promise<{
    totalSessions: number;
    activeSessions: number;
    averageSessionLength: number;
    languageDistribution: Record<string, number>;
    topIntents: Array<{ intent: string; count: number }>;
    satisfactionAverage: number;
    escalationRate: number;
  }> {
    const sessions = Array.from(this.sessions.values());
    const completedSessions = sessions.filter(s => s.endTime);

    const averageSessionLength = completedSessions.length > 0
      ? completedSessions.reduce((sum, s) => sum + (s.endTime!.getTime() - s.startTime.getTime()), 0) / completedSessions.length / 1000 / 60
      : 0;

    const languageDistribution = sessions.reduce((acc, session) => {
      acc[session.language] = (acc[session.language] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    const satisfactionRatings = sessions.filter(s => s.satisfaction).map(s => s.satisfaction!);
    const satisfactionAverage = satisfactionRatings.length > 0
      ? satisfactionRatings.reduce((sum, rating) => sum + rating, 0) / satisfactionRatings.length
      : 0;

    const escalatedSessions = sessions.filter(s => s.status === 'escalated').length;
    const escalationRate = sessions.length > 0 ? escalatedSessions / sessions.length : 0;

    return {
      totalSessions: sessions.length,
      activeSessions: sessions.filter(s => s.status === 'active').length,
      averageSessionLength,
      languageDistribution,
      topIntents: [], // Would be populated from intent tracking
      satisfactionAverage,
      escalationRate
    };
  }
}

class IntentClassifier {
  async classify(text: string, language: string): Promise<IntentClassification> {
    // Simplified intent classification based on keywords
    const lowerText = text.toLowerCase();
    
    let intent = 'general_inquiry';
    let confidence = 0.7;
    const entities: Entity[] = [];

    // Intent patterns for different languages
    const patterns = {
      greeting: ['hello', 'hi', 'hey', 'namaste', 'рдирдорд╕реНрддреЗ', 'ф╜ахе╜', 'ьХИыЕХ', 'уБУуВУуБлуБбуБп'],
      proof_generation: ['generate', 'create', 'proof', 'verification', 'verify', 'рдкреНрд░рдорд╛рдг', 'шпБцШО', 'ьжЭыкЕ', 'ши╝цШО'],
      account_issues: ['account', 'login', 'password', 'access', 'рдЦрд╛рддрд╛', 'ш┤жцИ╖', 'ъ│ДьаХ', 'уВвуВлуВжуГ│уГИ'],
      technical_support: ['error', 'bug', 'not working', 'problem', 'issue', 'рддреНрд░реБрдЯрд┐', 'щФЩшпп', 'ьШдыеШ', 'уВиуГйуГ╝'],
      pricing_info: ['price', 'cost', 'plan', 'subscription', 'рдореВрд▓реНрдп', 'ф╗╖ца╝', 'ъ░Аъ▓й', 'ф╛бца╝'],
      api_integration: ['api', 'integration', 'webhook', 'sdk', 'developer'],
      mobile_app: ['mobile', 'app', 'ios', 'android', 'download'],
      goodbye: ['bye', 'goodbye', 'thanks', 'thank you', 'рдзрдиреНрдпрд╡рд╛рдж', 'ш░вш░в', 'ъ░РьВм', 'уБВуВКуБМуБиуБЖ']
    };

    // Find matching intent
    for (const [intentName, keywords] of Object.entries(patterns)) {
      if (keywords.some(keyword => lowerText.includes(keyword))) {
        intent = intentName;
        confidence = 0.85;
        break;
      }
    }

    // Extract entities
    if (lowerText.includes('age')) {
      entities.push({ type: 'verification_type', value: 'age', confidence: 0.9 });
    }
    if (lowerText.includes('citizenship') || lowerText.includes('passport')) {
      entities.push({ type: 'verification_type', value: 'citizenship', confidence: 0.9 });
    }

    return {
      intent,
      confidence,
      entities,
      language
    };
  }
}

class LanguageDetector {
  async detect(text: string): Promise<string> {
    // Simplified language detection based on character patterns
    const hasDevanagari = /[\u0900-\u097F]/.test(text);
    const hasChinese = /[\u4e00-\u9fff]/.test(text);
    const hasKorean = /[\uac00-\ud7af]/.test(text);
    const hasJapanese = /[\u3040-\u309f\u30a0-\u30ff\u4e00-\u9faf]/.test(text);

    if (hasDevanagari) return 'ne';
    if (hasChinese) return 'zh';
    if (hasKorean) return 'ko';
    if (hasJapanese) return 'ja';
    return 'en';
  }
}

export const multilingualChatbot = new MultilingualChatbot();